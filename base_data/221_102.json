{
    "title": "\"Write various types of code programs.\"",
    "original_prompt": "Write a Python minesweeper code.",
    "split_prompt": "This is a prompt description:```json\n{\n    \"spliting prompt\": {\n        \"task\":[\n            \"Write\",\n            \"Create\",\n            \"Develop\"\n        ],\n        \"language\":[\n            \"Python\"\n        ],\n        \"game_type\":[\n            \"minesweeper\"\n        ],\n        \"output_format\":[\n            \"code\",\n            \"script\"\n        ]\n    }\n}\n```",
    "input1": " Create a Python program that implements a console-based Minesweeper game. The game should allow the player to choose the difficulty level (easy, medium, hard), which will determine the size of the grid and the number of mines. The player should be able to reveal cells, flag potential mines, and the game should end when the player either reveals a mine or successfully uncovers all non-mine cells. Include features such as a timer and a score based on the time taken and the number of moves made.\n\n",
    "input2": " Develop a Python script for a graphical Minesweeper game using the Tkinter library. The game should have a customizable grid size (e.g., 10x10, 16x16) and a variable number of mines based on the grid size. Implement a right-click feature to flag cells and a left-click feature to reveal cells. The game should display a message when the player wins or loses, and it should also include a reset button to start a new game. Additionally, provide an option to save and load game states.",
    "input1_ans": [
        "Here's a simple console-based Minesweeper game implemented in Python. This version allows players to choose a difficulty level, reveal cells, flag potential mines, and includes a timer and scoring system.\n\n```python\nimport random\nimport time\n\nclass Minesweeper:\n    def __init__(self, difficulty):\n        self.difficulty = difficulty\n        self.grid_size, self.num_mines = self.set_difficulty(difficulty)\n        self.grid = [[' ' for _ in range(self.grid_size)] for _ in range(self.grid_size)]\n        self.mines = set()\n        self.revealed = set()\n        self.flagged = set()\n        self.game_over = False\n        self.start_time = None\n\n    def set_difficulty(self, difficulty):\n        if difficulty == 'easy':\n            return 8, 10\n        elif difficulty == 'medium':\n            return 16, 40\n        elif difficulty == 'hard':\n            return 24, 99\n        else:\n            raise ValueError(\"Invalid difficulty level\")\n\n    def place_mines(self):\n        while len(self.mines) < self.num_mines:\n            x = random.randint(0, self.grid_size - 1)\n            y = random.randint(0, self.grid_size - 1)\n            self.mines.add((x, y))\n\n    def count_adjacent_mines(self, x, y):\n        count = 0\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if (x + i, y + j) in self.mines:\n                    count += 1\n        return count\n\n    def reveal_cell(self, x, y):\n        if (x, y) in self.revealed or (x, y) in self.flagged:\n            return\n        if (x, y) in self.mines:\n            self.game_over = True\n            return\n        self.revealed.add((x, y))\n        if self.count_adjacent_mines(x, y) == 0:\n            for i in range(-1, 2):\n                for j in range(-1, 2):\n                    if 0 <= x + i < self.grid_size and 0 <= y + j < self.grid_size:\n                        self.reveal_cell(x + i, y + j)\n\n    def flag_cell(self, x, y):\n        if (x, y) in self.revealed:\n            return\n        if (x, y) in self.flagged:\n            self.flagged.remove((x, y))\n        else:\n            self.flagged.add((x, y))\n\n    def print_grid(self):\n        print(\"   \" + \" \".join(str(i) for i in range(self.grid_size)))\n        for i in range(self.grid_size):\n            row = [str(i)] + [self.get_display_value(x, y) for x, y in enumerate(self.grid[i])]\n            print(\" \".join(row))\n\n    def get_display_value(self, x, y):\n        if (x, y) in self.revealed:\n            if (x, y) in self.mines:\n                return '*'\n            return str(self.count_adjacent_mines(x, y))\n        elif (x, y) in self.flagged:\n            return 'F'\n        else:\n            return ' '\n\n    def check_win(self):\n        return len(self.revealed) + len(self.mines) == self.grid_size ** 2\n\n    def play(self):\n        self.place_mines()\n        self.start_time = time.time()\n        while not self.game_over:\n            self.print_grid()\n            command = input(\"Enter command (reveal x y / flag x y / quit): \").strip().split()\n            if command[0] == 'quit':\n                print(\"Game exited.\")\n                break\n            elif command[0] == 'reveal':\n                x, y = int(command[1]), int(command[2])\n                self.reveal_cell(x, y)\n            elif command[0] == 'flag':\n                x, y = int(command[1]), int(command[2])\n                self.flag_cell(x, y)\n            else:\n                print(\"Invalid command.\")\n            if self.check_win():\n                self.game_over = True\n                print(\"Congratulations! You've cleared the minefield.\")\n                break\n        if self.game_over:\n            self.print_grid()\n            print(\"Game Over! You hit a mine.\")\n        elapsed_time = time.time() - self.start_time\n        print(f\"Time taken: {elapsed_time:.2f} seconds\")\n        print(f\"Moves made: {len(self.revealed) + len(self.flagged)}\")\n\nif __name__ == \"__main__\":\n    difficulty = input(\"Choose difficulty (easy, medium, hard): \").strip().lower()\n    game = Minesweeper(difficulty)\n    game.play()\n```\n\n### How to Play:\n1. Run the script in a Python environment.\n2. Choose a difficulty level: easy, medium, or hard.\n3. Use the commands:\n   - `reveal x y` to reveal a cell at coordinates (x, y).\n   - `flag x y` to flag a cell as a potential mine.\n   - `quit` to exit the game.\n4. The game ends when you reveal a mine or successfully uncover all non-mine cells.\n\n### Features:\n- Difficulty levels that change the grid size and number of mines.\n- A timer that tracks how long the game takes.\n- A score based on the time taken and the number of moves made.\n\nFeel free to modify and enhance the game further!",
        "Here's a Python program that implements a console-based Minesweeper game. The player can choose the difficulty level, reveal cells, flag potential mines, and the game tracks the time taken and the number of moves made.\n\n```python\nimport random\nimport time\n\nclass Minesweeper:\n    def __init__(self, difficulty):\n        self.difficulty = difficulty\n        self.grid_size, self.num_mines = self.set_difficulty(difficulty)\n        self.grid = [[' ' for _ in range(self.grid_size)] for _ in range(self.grid_size)]\n        self.mines = set()\n        self.revealed = set()\n        self.flagged = set()\n        self.game_over = False\n        self.start_time = None\n\n    def set_difficulty(self, difficulty):\n        if difficulty == 'easy':\n            return 8, 10\n        elif difficulty == 'medium':\n            return 16, 40\n        elif difficulty == 'hard':\n            return 24, 99\n        else:\n            raise ValueError(\"Invalid difficulty level\")\n\n    def place_mines(self):\n        while len(self.mines) < self.num_mines:\n            x = random.randint(0, self.grid_size - 1)\n            y = random.randint(0, self.grid_size - 1)\n            self.mines.add((x, y))\n\n    def print_grid(self):\n        print(\"   \" + \" \".join(str(i) for i in range(self.grid_size)))\n        for i in range(self.grid_size):\n            row = f\"{i} | \" + \" \".join(self.grid[i])\n            print(row)\n\n    def count_adjacent_mines(self, x, y):\n        count = 0\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if (x + i, y + j) in self.mines:\n                    count += 1\n        return count\n\n    def reveal_cell(self, x, y):\n        if (x, y) in self.revealed or (x, y) in self.flagged:\n            return\n        if (x, y) in self.mines:\n            self.game_over = True\n            return\n        self.revealed.add((x, y))\n        mine_count = self.count_adjacent_mines(x, y)\n        self.grid[x][y] = str(mine_count) if mine_count > 0 else ' '\n\n        if mine_count == 0:\n            for i in range(-1, 2):\n                for j in range(-1, 2):\n                    if 0 <= x + i < self.grid_size and 0 <= y + j < self.grid_size:\n                        self.reveal_cell(x + i, y + j)\n\n    def flag_cell(self, x, y):\n        if (x, y) not in self.revealed:\n            if (x, y) in self.flagged:\n                self.flagged.remove((x, y))\n                self.grid[x][y] = ' '\n            else:\n                self.flagged.add((x, y))\n                self.grid[x][y] = 'F'\n\n    def check_win(self):\n        return len(self.revealed) + len(self.mines) == self.grid_size ** 2\n\n    def play(self):\n        self.place_mines()\n        self.start_time = time.time()\n        while not self.game_over:\n            self.print_grid()\n            action = input(\"Enter action (reveal x y / flag x y): \").split()\n            if action[0] == 'reveal':\n                x, y = int(action[1]), int(action[2])\n                self.reveal_cell(x, y)\n            elif action[0] == 'flag':\n                x, y = int(action[1]), int(action[2])\n                self.flag_cell(x, y)\n\n            if self.check_win():\n                self.game_over = True\n                print(\"Congratulations! You've cleared the minefield.\")\n                break\n\n        if self.game_over:\n            print(\"Game Over! You hit a mine.\")\n            for x, y in self.mines:\n                self.grid[x][y] = '*'\n            self.print_grid()\n\n        end_time = time.time()\n        time_taken = end_time - self.start_time\n        score = max(0, (self.grid_size ** 2 - len(self.revealed)) - int(time_taken))\n        print(f\"Time taken: {time_taken:.2f} seconds, Score: {score}\")\n\nif __name__ == \"__main__\":\n    difficulty = input(\"Choose difficulty (easy, medium, hard): \").strip().lower()\n    game = Minesweeper(difficulty)\n    game.play()\n```\n\n### How to Play:\n1. Run the program.\n2. Choose a difficulty level: easy, medium, or hard.\n3. Use the command `reveal x y` to reveal a cell at coordinates (x, y).\n4. Use the command `flag x y` to flag a cell as a potential mine.\n5. The game ends when you reveal a mine or successfully uncover all non-mine cells.\n6. Your score is calculated based on the time taken and the number of moves made.\n\n### Features:\n- Difficulty levels that change the grid size and number of mines.\n- Ability to reveal cells and flag potential mines.\n- Game over conditions and win conditions.\n- Timer and scoring system based on performance."
    ],
    "input2_ans": [
        "Creating a Minesweeper game using the Tkinter library in Python is a fun project! Below is a complete implementation that includes customizable grid sizes, mine placement, flagging, revealing cells, win/lose conditions, and the ability to save and load game states.\n\n```python\nimport tkinter as tk\nfrom tkinter import messagebox\nimport random\nimport pickle\n\nclass Minesweeper:\n    def __init__(self, master, width=10, height=10, mines=10):\n        self.master = master\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.game_over = False\n        self.board = [[0 for _ in range(width)] for _ in range(height)]\n        self.revealed = [[False for _ in range(width)] for _ in range(height)]\n        self.flagged = [[False for _ in range(width)] for _ in range(height)]\n        self.buttons = [[None for _ in range(width)] for _ in range(height)]\n        self.create_widgets()\n        self.place_mines()\n        self.calculate_numbers()\n\n    def create_widgets(self):\n        self.frame = tk.Frame(self.master)\n        self.frame.pack()\n        for i in range(self.height):\n            for j in range(self.width):\n                button = tk.Button(self.frame, text='', width=3, height=1,\n                                   command=lambda x=i, y=j: self.reveal(x, y))\n                button.bind(\"<Button-3>\", lambda event, x=i, y=j: self.flag(x, y))\n                button.grid(row=i, column=j)\n                self.buttons[i][j] = button\n        self.reset_button = tk.Button(self.master, text='Reset', command=self.reset)\n        self.reset_button.pack()\n        self.save_button = tk.Button(self.master, text='Save', command=self.save_game)\n        self.save_button.pack()\n        self.load_button = tk.Button(self.master, text='Load', command=self.load_game)\n        self.load_button.pack()\n\n    def place_mines(self):\n        mine_positions = random.sample(range(self.width * self.height), self.mines)\n        for pos in mine_positions:\n            x, y = divmod(pos, self.width)\n            self.board[x][y] = -1  # -1 represents a mine\n\n    def calculate_numbers(self):\n        for i in range(self.height):\n            for j in range(self.width):\n                if self.board[i][j] == -1:\n                    continue\n                count = 0\n                for x in range(max(0, i-1), min(self.height, i+2)):\n                    for y in range(max(0, j-1), min(self.width, j+2)):\n                        if self.board[x][y] == -1:\n                            count += 1\n                self.board[i][j] = count\n\n    def reveal(self, x, y):\n        if self.game_over or self.revealed[x][y] or self.flagged[x][y]:\n            return\n        self.revealed[x][y] = True\n        if self.board[x][y] == -1:\n            self.game_over = True\n            self.buttons[x][y].config(text='*', bg='red')\n            messagebox.showinfo(\"Game Over\", \"You hit a mine!\")\n            self.show_all_mines()\n        else:\n            self.buttons[x][y].config(text=str(self.board[x][y]), state='disabled')\n            if self.board[x][y] == 0:\n                for i in range(max(0, x-1), min(self.height, x+2)):\n                    for j in range(max(0, y-1), min(self.width, y+2)):\n                        self.reveal(i, j)\n            if self.check_win():\n                self.game_over = True\n                messagebox.showinfo(\"Congratulations\", \"You won!\")\n\n    def flag(self, x, y):\n        if self.game_over or self.revealed[x][y]:\n            return\n        self.flagged[x][y] = not self.flagged[x][y]\n        self.buttons[x][y].config(text='F' if self.flagged[x][y] else '', bg='yellow' if self.flagged[x][y] else 'SystemButtonFace')\n\n    def show_all_mines(self):\n        for i in range(self.height):\n            for j in range(self.width):\n                if self.board[i][j] == -1:\n                    self.buttons[i][j].config(text='*', bg='red')\n\n    def check_win(self):\n        for i in range(self.height):\n            for j in range(self.width):\n                if self.board[i][j] != -1 and not self.revealed[i][j]:\n                    return False\n        return True\n\n    def reset(self):\n        self.game_over = False\n        self.board = [[0 for _ in range(self.width)] for _ in range(self.height)]\n        self.revealed = [[False for _ in range(self.width)] for _ in range(self.height)]\n        self.flagged = [[False for _ in range(self.width)] for _ in range(self.height)]\n        for i in range(self.height):\n            for j in range(self.width):\n                self.buttons[i][j].config(text='', state='normal', bg='SystemButtonFace')\n        self.place_mines()\n        self.calculate_numbers()\n\n    def save_game(self):\n        with open('minesweeper_save.pkl', 'wb') as f:\n            pickle.dump((self.board, self.revealed, self.flagged, self.game_over), f)\n\n    def load_game(self):\n        try:\n            with open('minesweeper_save.pkl', 'rb') as f:\n                self.board, self.revealed, self.flagged, self.game_over = pickle.load(f)\n                for i in range(self.height):\n                    for j in range(self.width):\n                        if self.revealed[i][j]:\n                            self.buttons[i][j].config(text=str(self.board[i][j]), state='disabled')\n                        if self.flagged[i][j]:\n                            self.buttons[i][j].config(text='F', bg='yellow')\n        except FileNotFoundError:\n            messagebox.showerror(\"Error\", \"No saved game found.\")\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    root.title(\"Minesweeper\")\n    game = Minesweeper(root, width=10, height=10, mines=10)\n    root.mainloop()\n```\n\n### Explanation of the Code:\n1. **Class Structure**: The `Minesweeper` class encapsulates all the game logic and UI components.\n2. **Game Initialization**: The constructor initializes the game board, revealed states, and flagged states. It also creates the UI buttons.\n3. **Mine Placement**: Randomly places mines on the board and calculates the numbers for adjacent cells.\n4. **Reveal and Flag Functions**: Implements the logic for revealing cells and flagging them with right-clicks.\n5. **Win/Lose Conditions**: Checks for game over conditions and displays messages accordingly.\n6. **Reset, Save, and Load**: Provides functionality to reset the game, save the current state, and load a saved state.\n\n### How to Run:\n1. Make sure you have Python installed on your machine.\n2. Copy the code into a Python file (e.g., `minesweeper.py`).\n3. Run the script using Python: `python minesweeper.py`.\n\nYou can customize the grid size and number of mines by modifying the parameters in the `Minesweeper` class instantiation. Enjoy playing Minesweeper!",
        "Here's a Python script that implements a graphical Minesweeper game using the Tkinter library. The game features a customizable grid size, variable number of mines, right-click to flag cells, left-click to reveal cells, and options to save and load game states.\n\n```python\nimport tkinter as tk\nfrom tkinter import messagebox, simpledialog\nimport random\nimport pickle\n\nclass Minesweeper:\n    def __init__(self, master, grid_size=10, num_mines=10):\n        self.master = master\n        self.grid_size = grid_size\n        self.num_mines = num_mines\n        self.is_game_over = False\n        self.board = [[0 for _ in range(grid_size)] for _ in range(grid_size)]\n        self.revealed = [[False for _ in range(grid_size)] for _ in range(grid_size)]\n        self.flagged = [[False for _ in range(grid_size)] for _ in range(grid_size)]\n        self.buttons = [[None for _ in range(grid_size)] for _ in range(grid_size)]\n        self.create_widgets()\n        self.place_mines()\n        self.calculate_numbers()\n\n    def create_widgets(self):\n        self.frame = tk.Frame(self.master)\n        self.frame.pack()\n        self.reset_button = tk.Button(self.master, text=\"Reset\", command=self.reset_game)\n        self.reset_button.pack()\n        self.save_button = tk.Button(self.master, text=\"Save\", command=self.save_game)\n        self.save_button.pack()\n        self.load_button = tk.Button(self.master, text=\"Load\", command=self.load_game)\n        self.load_button.pack()\n\n        for i in range(self.grid_size):\n            for j in range(self.grid_size):\n                button = tk.Button(self.frame, text='', width=3, height=1,\n                                   command=lambda x=i, y=j: self.reveal_cell(x, y))\n                button.bind(\"<Button-3>\", lambda event, x=i, y=j: self.flag_cell(x, y))\n                button.grid(row=i, column=j)\n                self.buttons[i][j] = button\n\n    def place_mines(self):\n        mines_placed = 0\n        while mines_placed < self.num_mines:\n            x = random.randint(0, self.grid_size - 1)\n            y = random.randint(0, self.grid_size - 1)\n            if self.board[x][y] != -1:\n                self.board[x][y] = -1\n                mines_placed += 1\n\n    def calculate_numbers(self):\n        for i in range(self.grid_size):\n            for j in range(self.grid_size):\n                if self.board[i][j] == -1:\n                    continue\n                for x in range(max(0, i-1), min(self.grid_size, i+2)):\n                    for y in range(max(0, j-1), min(self.grid_size, j+2)):\n                        if self.board[x][y] == -1:\n                            self.board[i][j] += 1\n\n    def reveal_cell(self, x, y):\n        if self.is_game_over or self.revealed[x][y] or self.flagged[x][y]:\n            return\n        self.revealed[x][y] = True\n        if self.board[x][y] == -1:\n            self.buttons[x][y].config(text='*', bg='red')\n            self.is_game_over = True\n            messagebox.showinfo(\"Game Over\", \"You hit a mine! Game Over.\")\n            return\n        elif self.board[x][y] == 0:\n            self.buttons[x][y].config(text='', bg='lightgrey')\n            for i in range(max(0, x-1), min(self.grid_size, x+2)):\n                for j in range(max(0, y-1), min(self.grid_size, y+2)):\n                    self.reveal_cell(i, j)\n        else:\n            self.buttons[x][y].config(text=str(self.board[x][y]), bg='lightgrey')\n        \n        if self.check_win():\n            messagebox.showinfo(\"Congratulations\", \"You've cleared the minefield!\")\n\n    def flag_cell(self, x, y):\n        if self.is_game_over or self.revealed[x][y]:\n            return\n        self.flagged[x][y] = not self.flagged[x][y]\n        self.buttons[x][y].config(text='F' if self.flagged[x][y] else '', bg='yellow' if self.flagged[x][y] else 'SystemButtonFace')\n\n    def check_win(self):\n        for i in range(self.grid_size):\n            for j in range(self.grid_size):\n                if not self.revealed[i][j] and self.board[i][j] != -1:\n                    return False\n        return True\n\n    def reset_game(self):\n        self.is_game_over = False\n        self.board = [[0 for _ in range(self.grid_size)] for _ in range(self.grid_size)]\n        self.revealed = [[False for _ in range(self.grid_size)] for _ in range(self.grid_size)]\n        self.flagged = [[False for _ in range(self.grid_size)] for _ in range(self.grid_size)]\n        for i in range(self.grid_size):\n            for j in range(self.grid_size):\n                self.buttons[i][j].config(text='', bg='SystemButtonFace')\n        self.place_mines()\n        self.calculate_numbers()\n\n    def save_game(self):\n        with open('minesweeper_save.pkl', 'wb') as f:\n            pickle.dump((self.board, self.revealed, self.flagged, self.is_game_over), f)\n        messagebox.showinfo(\"Save Game\", \"Game saved successfully!\")\n\n    def load_game(self):\n        try:\n            with open('minesweeper_save.pkl', 'rb') as f:\n                self.board, self.revealed, self.flagged, self.is_game_over = pickle.load(f)\n            for i in range(self.grid_size):\n                for j in range(self.grid_size):\n                    if self.revealed[i][j]:\n                        self.buttons[i][j].config(text=str(self.board[i][j]), bg='lightgrey')\n                    elif self.flagged[i][j]:\n                        self.buttons[i][j].config(text='F', bg='yellow')\n                    else:\n                        self.buttons[i][j].config(text='', bg='SystemButtonFace')\n            messagebox.showinfo(\"Load Game\", \"Game loaded successfully!\")\n        except FileNotFoundError:\n            messagebox.showerror(\"Load Game\", \"No saved game found.\")\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    root.title(\"Minesweeper\")\n    grid_size = simpledialog.askinteger(\"Grid Size\", \"Enter grid size (e.g., 10 for 10x10):\", minvalue=5, maxvalue=30)\n    num_mines = simpledialog.askinteger(\"Number of Mines\", \"Enter number of mines:\", minvalue=1, maxvalue=grid_size*grid_size//2)\n    game = Minesweeper(root, grid_size, num_mines)\n    root.mainloop()\n```\n\n### Instructions to Run the Game:\n1. Make sure you have Python installed on your machine.\n2. Copy the above code into a Python file, e.g., `minesweeper.py`.\n3. Run the script using the command `python minesweeper.py`.\n4. A window will pop up asking for the grid size and the number of mines.\n5. Use left-click to reveal cells and right-click to flag cells.\n6. Use the \"Reset\" button to start a new game, and the \"Save\" and \"Load\" buttons to manage game states.\n\n### Features:\n- Customizable grid size and number of mines.\n- Right-click to flag and left-click to reveal cells.\n- Game over message when hitting a mine.\n- Win message when all non-mine cells are revealed.\n- Save and load game states using pickle."
    ]
}