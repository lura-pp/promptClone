{
    "title": "Video Summarizer GPT",
    "original_prompt": "Act as a summarizer. You will summarize the transcript of an online course. I will provide you the transcript of the online course. Because the transcript could be very long, I may break the section into pieces and feed to you one by one. \n\nThe summarize should be comprehensive and concise. It should be understandable by 17 year old teenager. Some of the formatting tips:\nHighlight important works/lines in bold.\nUse third party tone. \n\n{Your Transcript to summarize:One of the exciting things about a large  language model is you can use it to build a custom chatbot  with only a modest amount of effort. ChatGPT, the web interface,  is a way for you to have a conversational interface,  a conversation via a large language model. But one of the  cool things is you can also use a large language model to  build your custom chatbot to maybe play the role of an AI  customer service agent or an AI order taker for a restaurant.  And in this video, you learn how to do that for yourself.  I'm going to describe the components of  the OpenAI ChatCompletions format in more  detail, and then you're going to build a chatbot yourself. So let's  get into it. So first, we'll set up the OpenAI Python package as  usual.  So chat models like ChatGPT are actually trained  to take a series of messages as input  and return a model-generated message as output. And  so although the chat format is designed to make multi-turn conversations  like this easy, we've kind of seen through the previous videos  that it's also just as useful for single-turn tasks without any conversation.  And so next, we're going to kind of define two helper functions. So  this is the one that we've been using throughout all the videos,  and it's the getCompletion function. But if you kind  of look at it, we give a prompt, but then kind of  inside the function, what we're actually doing is putting this prompt  into what looks    like some kind of user message. And this is because the  ChatGPT model is a chat model, which means it's trained to take a series  of messages as input and then return a model-generated message  as output. So the user message is kind of the input, and  then the assistant message is the output.  So, in this video, we're going to actually use  a different helper function, and instead of kind of  putting a single prompt as input and getting  a single completion, we're going to pass in a list of messages. And these  messages can be kind of from a variety  of different roles, so I'll describe those. So here's an example of  a list of messages. And so, the first message is  a system message, which kind of gives an overall instruction, and then after  this message, we have kind of  turns between the user and the assistant. And this would kind  of continue to go on. And if you've ever used ChatGPT, the  web interface, then  your messages are the user messages, and then ChatGPT's  messages are the assistant messages. So the system message helps  to kind of set the behaviour and persona  of the assistant, and it acts as kind of a high-level instruction  for the conversation. So you can kind of think of it as whispering  in the assistant's ear and kind of guiding it's responses without the  user being aware of the system message. So, as the user, if  you've ever used ChatGPT, you probably don't know what's  in ChatGPT's system message, and that's kind of the intention. The benefit  of the system message is that it provides you, the developer, with  a way to kind of frame the conversation without making the  request itself part of the conversation. So you can  kind of guide the assistant and kind of whisper in  its ear and guide its responses without making the user aware.    So, now let's try to use these messages in a conversation.  So we'll use our new helper function to get the  completion from the messages.  And we're also using a higher temperature.  So the system message says, you are an assistant  that speaks like Shakespeare. So this is us kind of describing to  the assistant how it should behave. And then the first user message is,  tell me a joke. The next is, why did the chicken cross the road?  And then the final user message is, I don't know.  So if we run this,  the response is to get to the other side. Let's try again.  To get to the other side, faire so, madame,  tis an olden classic that never fails. So there's  our Shakespearean response.  And let's actually try one more thing, because  I want to make it even clearer that  this is the assistant message. So here, let's just  go and print the  entire message response.  So, just to make this even clearer, uhm, this  response is an assistant message. So, the role is assistant  and then the content is the message itself. So, that's  what's happening in this helper function. We're just  kind of passing out the content of the message.  now let's do another example. So, here our messages are, uhm, the  assistant message is, you're a friendly chatbot and the first  user message is, hi, my name is Isa. And we want to, uhm,    get the first user message. So, let's execute this. The  first assistant message.  And so, the first message is, hello Isa, it's nice to meet you. How  can I assist you today?  Now, let's try another example.  So, here our messages are, uhm, system message, you're  a friendly chatbot and the first user message is, yes,  can you remind me  what is my name? And let's get the response.  And as you can see,  the model doesn't actually know my name.  So, each conversation with a language model is a standalone  interaction which means that you must provide all relevant  messages for the model to draw from in the current conversation.  If you want the model to draw from or, quote unquote,  remember earlier parts of a conversation,  you must provide the earlier exchanges in the  input to the model. And so, we'll refer to this as context. So, let's  try this.  So, now we've kind of given the context that the model needs, uhm, which  is my name in the previous messages and we'll ask  the same question, so we'll ask what my name is.  And the model is able to respond because it has  all of the context it needs, uhm, in this kind of list of  messages that we input to it.  So now you're going to build your own chatbot.  This chatbot is going to be called orderbot, and  we're going to automate the collection of  user prompts and assistant responses in order to build  this orderbot. And it's going to take orders at a pizza restaurant, so  first we're going to define this helper function, and what this  is doing is it's going to kind of collect our user messages  so we can avoid typing them in by hand in  the same, in the way that we did above, and this is going  to kind of collect prompts from a user  interface that will build below, and then append it  to a list called context, and then it will call the model with  that context every time. And the model response  is then also added to the context, so the kind of    model message is added to the context, the user message is  added to the context, so on, so it just kind of grows longer and  longer.  This way the model has the information it needs to  determine what to do next. And so now we'll  set up and run this kind of UI to display the order bot, and  so here's the context, and it contains the system message that  contains the menu,  and note that every time we call the language model we're  going to use the same context, and the context is building  up over time.  And then let's execute this.  Okay, I'm going to say, hi, I would like to order a pizza.  And the assistant says, great, what pizza would you like to order?  We have pepperoni, cheese, and eggplant pizza.  How much are they?  Great, okay, we have the prices.  I think I'm feeling a medium eggplant pizza.  So as you can imagine, we could kind of continue this conversation,  and let's kind of look at what we've put in the system message.  So you are order bot, an automated service  to collect orders for a pizza restaurant.  You first greet the customer, then collect the order,  and then ask if it's a pickup or delivery. You  wait to collect the entire order, then summarize it and check  for a final time if the customer wants  to add anything else. If it's a delivery, you can  ask for an address. Finally, you collect the payment. Make sure  to clarify all options, extras, and sizes  to uniquely identify the item from the menu. You respond  in a short, very conversational, friendly style.  The menu includes, and then here we have the menu.  So let's go back to our conversation and let's see  if the assistant kind of has been following the instructions.  Okay, great, the assistant asks if we want any toppings  which we kind of specified an assistant message.  So I think we want no extra toppings.  Things... sure thing. Is there anything else we'd  like to order? Hmm,  let's get some water. Actually,  fries.  Small or large? And this is great because we kind of  asked the assistant in the system message to  kind of clarify extras and sides.  And so you get the idea and please feel free  to play with this yourself. You can pause the video and just go  ahead and run this in your own notebook on the left.  And so now we can ask the model to create a JSON  summary that we could send to the order  system based on the conversation.  So we're now appending another system message which is an  instruction and we're saying create a JSON summary of  the previous food order, itemize the price for each item, the fields  should be one pizza, include side,  two lists of toppings, three lists of drinks,  and four lists of sides, and finally the total price.  And you could also  use a user message here, this does not have to be a system  message.  So let's execute this.  And notice in this case we're using a lower  temperature because for these kinds of tasks we want  the output to be fairly predictable. For  a conversational agent you might want to use  a higher temperature, however in this case I  would maybe use a lower temperature as well  because for a customer's assistant chatbot you might want  the output to be a bit more predictable as well.  And so here we have the summary of our order and so  we could submit this to the order system if we wanted to.  So there we have it, you've built your very own order chatbot. Feel  free to kind of customize it yourself and play around with the  system message to kind of change the behavior of the chatbot and  kind of get it to act as different personas  with different knowledge. }",
    "split_prompt": "This is a prompt description:```json\n{\n    \"spliting prompt\": {\n        \"Purpose\": [\n            \"Summarize the transcript of an online course.\"\n        ],\n        \"Target Audience\": [\n            \"17 year old teenager\"\n        ],\n        \"Formatting Guidelines\": [\n            \"Highlight important words/lines in bold.\",\n            \"Use third party tone.\"\n        ],\n        \"Content Overview\": [\n            \"Introduction to building a custom chatbot using a large language model.\",\n            \"Explanation of the OpenAI ChatCompletions format.\",\n            \"Description of helper functions for chatbot interaction.\",\n            \"Importance of system messages in guiding chatbot behavior.\",\n            \"Examples of user and assistant messages in a conversation.\",\n            \"Building an order-taking chatbot for a pizza restaurant.\",\n            \"Collecting user prompts and assistant responses.\",\n            \"Creating a JSON summary of the food order.\"\n        ],\n        \"Key Concepts\": [\n            \"Chat models are trained for multi-turn conversations.\",\n            \"System messages set the behavior and persona of the assistant.\",\n            \"Context is crucial for the model to remember previous interactions.\",\n            \"The orderbot automates the collection of pizza orders.\",\n            \"Temperature settings affect the predictability of responses.\"\n        ],\n        \"Examples\": [\n            \"User asks for a joke, assistant responds in Shakespearean style.\",\n            \"User interacts with a friendly chatbot, asking for their name.\",\n            \"Orderbot collects pizza orders and clarifies options.\"\n        ],\n        \"Conclusion\": [\n            \"Encouragement to customize and experiment with the chatbot.\"\n        ]\n    }\n}\n```",
    "input1": " One of the most fascinating aspects of large language models is their ability to create personalized chatbots with minimal effort. For instance, ChatGPT serves as a conversational interface that allows users to interact with a large language model. This technology can be utilized to develop a custom chatbot that functions as an AI customer service representative or an AI order taker for a restaurant. In this segment, we will explore how to construct such a chatbot. We will delve into the components of the OpenAI ChatCompletions format in detail, and by the end, you will have the skills to build your own chatbot. First, we will set up the OpenAI Python package as usual. Chat models like ChatGPT are specifically trained to process a series of messages as input and generate a model-generated message as output. While the chat format is designed for multi-turn conversations, it is equally effective for single-turn tasks. Next, we will define two helper functions. The first function, getCompletion, has been used throughout the course. It takes a prompt and formats it as a user message, as the ChatGPT model is designed to handle a series of messages. In this video, we will introduce a different helper function that accepts a list of messages, which can come from various roles. For example, the first message could be a system message that provides overarching instructions, followed by turns between the user and the assistant. The system message sets the assistant's behavior and persona, acting as a high-level instruction for the conversation. This allows developers to frame the conversation without the user being aware of the system message. Now, let's see how to use these messages in a conversation. We will employ our new helper function to obtain a completion from the messages, using a higher temperature setting. For instance, if the system message instructs the assistant to speak like Shakespeare, and the user asks for a joke, the assistant might respond with a classic line. We will also explore how to print the entire message response for clarity. In another example, we will demonstrate how the assistant can respond to user messages while maintaining context. Each interaction with the language model is standalone, meaning all relevant messages must be provided for the model to respond accurately. Finally, we will build a chatbot named OrderBot, designed to automate the collection of user prompts and assistant responses for a pizza restaurant. We will define a helper function to collect user messages and append them to a context list, which will grow as the conversation progresses. The assistant will greet the customer, collect the order, and inquire about pickup or delivery options. The system message will guide the assistant's behavior, ensuring it clarifies options and extras. We will also create a JSON summary of the order, itemizing prices and including details such as pizza type, sides, and total cost. This comprehensive approach allows for a customizable and interactive chatbot experience.\n\n",
    "input2": " The potential of large language models to create tailored chatbots is truly remarkable. ChatGPT, as a web interface, enables users to engage in conversations with a large language model effortlessly. This technology can be harnessed to develop a custom chatbot that serves various purposes, such as acting as an AI customer service agent or an AI order taker for a restaurant. In this lesson, we will guide you through the process of building your own chatbot. We will examine the components of the OpenAI ChatCompletions format in detail, equipping you with the knowledge to create a chatbot from scratch. To begin, we will set up the OpenAI Python package. Chat models like ChatGPT are trained to accept a series of messages as input and produce a model-generated message as output. While the chat format is optimized for multi-turn conversations, it is also effective for single-turn tasks. We will define two helper functions, starting with the getCompletion function, which formats a prompt as a user message. This is essential because the ChatGPT model is designed to handle a series of messages. In this video, we will introduce a new helper function that takes a list of messages from different roles. The first message could be a system message that provides overall instructions, followed by user and assistant messages. The system message is crucial as it sets the assistant's behavior and persona, guiding its responses without the user being aware of its content. Now, let's explore how to implement these messages in a conversation. We will use our new helper function to obtain a completion from the messages, adjusting the temperature for varied responses. For example, if the system message instructs the assistant to respond in a Shakespearean style, the user might ask for a joke, and the assistant would deliver a witty response. We will also demonstrate how to print the entire message response for clarity. In another scenario, we will illustrate how the assistant can respond to user messages while maintaining context. Each conversation with the language model is independent, meaning all relevant messages must be provided for accurate responses. Finally, we will create a chatbot named OrderBot, designed to streamline the process of collecting user prompts and assistant responses for a pizza restaurant. We will define a helper function to gather user messages and append them to a context list, which will expand as the conversation unfolds. The assistant will greet the customer, gather the order, and ask whether it is for pickup or delivery. The system message will guide the assistant's behavior, ensuring it clarifies options and extras. We will also generate a JSON summary of the order, detailing prices and including information such as pizza type, sides, and total cost. This comprehensive approach allows for a customizable and engaging chatbot experience.",
    "input1_ans": [
        "In this segment, the course discusses the **exciting potential of large language models** to create personalized chatbots with minimal effort. **ChatGPT** serves as a conversational interface, enabling users to interact with a large language model. This technology can be used to develop custom chatbots, such as an **AI customer service representative** or an **AI order taker for a restaurant**.\n\nThe course outlines how to construct such a chatbot by exploring the **OpenAI ChatCompletions format**. It begins with setting up the **OpenAI Python package** and explaining that chat models like ChatGPT are trained to process a series of messages as input and generate responses as output. While designed for multi-turn conversations, this format is also effective for single-turn tasks.\n\nTwo helper functions are defined, with the first being **getCompletion**, which formats a prompt as a user message. The new helper function accepts a **list of messages** from various roles, starting with a **system message** that provides overarching instructions. This system message sets the assistant's behavior and persona, allowing developers to guide the conversation without the user being aware of it.\n\nThe course demonstrates how to use these messages in a conversation, including examples where the assistant responds in a specific style, such as **speaking like Shakespeare**. It emphasizes that each interaction with the language model is standalone, meaning all relevant messages must be provided for accurate responses.\n\nFinally, the course introduces the **OrderBot**, a chatbot designed to automate the collection of user prompts and assistant responses for a pizza restaurant. A helper function is defined to collect user messages and append them to a **context list**, which grows as the conversation progresses. The assistant will greet customers, collect orders, and ask about pickup or delivery options, guided by a system message that clarifies options and extras. The course concludes with the creation of a **JSON summary** of the order, detailing prices and items, allowing for a customizable and interactive chatbot experience.",
        "In this segment, we will **explore the fascinating world of building personalized chatbots** using large language models like ChatGPT. This technology enables the creation of custom chatbots that can serve as **AI customer service representatives** or **AI order takers** for restaurants. By the end of this course, you will have the skills to construct your own chatbot!\n\n### Key Components of Chatbot Development\n\n1. **Setting Up the OpenAI Python Package**: \n   - We will begin by setting up the **OpenAI Python package** to facilitate our chatbot development.\n\n2. **Understanding Chat Models**: \n   - Chat models, such as ChatGPT, are specifically trained to handle **multi-turn conversations**. However, they are also effective for **single-turn tasks**.\n\n3. **Helper Functions**: \n   - We will define two **helper functions**:\n     - The first function, **getCompletion**, formats a prompt as a user message.\n     - The second function accepts a list of messages from various roles, including a **system message** that sets the assistant's behavior and persona.\n\n### Importance of System Messages\n\n- The **system message** provides overarching instructions for the assistant, allowing developers to frame the conversation without the user being aware of it. This is crucial for guiding the assistant's responses.\n\n### Practical Examples\n\n- We will see how to use these messages in a conversation. For instance, if the system message instructs the assistant to speak like **Shakespeare**, and the user asks for a joke, the assistant might respond with a classic line. \n\n- Each interaction with the language model is **standalone**, meaning all relevant messages must be provided for accurate responses.\n\n### Building the OrderBot\n\n- We will create a chatbot named **OrderBot**, designed to automate the collection of pizza orders. The assistant will:\n  - Greet the customer.\n  - Collect the order.\n  - Inquire about **pickup or delivery options**.\n\n- The system message will guide the assistant's behavior, ensuring it clarifies options and extras. \n\n- Finally, we will create a **JSON summary** of the order, itemizing prices and including details such as pizza type, sides, and total cost.\n\n### Conclusion\n\nThis comprehensive approach allows for a **customizable and interactive chatbot experience**. You are encouraged to **experiment and customize** your chatbot to suit your needs!"
    ],
    "input2_ans": [
        "The lesson highlights the **remarkable potential** of large language models, like ChatGPT, to create **custom chatbots** for various applications, such as **AI customer service agents** or **restaurant order takers**. It guides users through the process of building their own chatbot by examining the **OpenAI ChatCompletions format**.\n\nTo start, users will set up the **OpenAI Python package**. Chat models are designed to handle a series of messages, making them suitable for both **multi-turn conversations** and **single-turn tasks**. The lesson introduces two helper functions, including the **getCompletion function**, which formats prompts as user messages. A new helper function will also be introduced to manage a **list of messages** from different roles, including a **system message** that sets the assistant's behavior and persona without the user's awareness.\n\nThe lesson demonstrates how to implement these messages in a conversation, adjusting the **temperature** for varied responses. For instance, if the assistant is instructed to respond in a **Shakespearean style**, it will deliver witty responses to user prompts. It also emphasizes the importance of maintaining **context** in conversations, as each interaction is independent and requires all relevant messages for accurate responses.\n\nFinally, the lesson culminates in the creation of a chatbot named **OrderBot**, which automates the collection of user orders for a pizza restaurant. A helper function will gather user messages and append them to a **context list**, allowing the assistant to greet customers, collect orders, and clarify options. The system message will guide the assistant's behavior, ensuring it effectively manages the conversation. Additionally, a **JSON summary** of the order will be generated, detailing prices and including information such as pizza type, sides, and total cost. This comprehensive approach enables users to create a **customizable and engaging chatbot experience**.",
        "In this lesson, we will explore the **remarkable potential** of large language models, specifically focusing on how to build a **custom chatbot** using the OpenAI ChatCompletions format. This technology can be utilized for various applications, such as an **AI customer service agent** or an **AI order taker** for restaurants.\n\n### Key Components of Building a Chatbot\n\n1. **Setting Up**: We will start by setting up the **OpenAI Python package** to facilitate our chatbot development.\n\n2. **Understanding Chat Models**: Chat models like **ChatGPT** are designed to handle a series of messages, making them suitable for both **multi-turn** and **single-turn** conversations.\n\n3. **Helper Functions**: \n   - We will define two **helper functions**. The first, **getCompletion**, formats a prompt as a user message, which is essential for the model's operation.\n   - The second helper function will manage a list of messages from different roles, including a **system message** that sets the assistant's behavior and persona.\n\n### Importance of System Messages\n\nThe **system message** is crucial as it guides the assistant's responses without the user being aware of its content. For instance, if the system message instructs the assistant to respond in a **Shakespearean style**, the user might ask for a joke, and the assistant would deliver a witty response.\n\n### Maintaining Context in Conversations\n\nEach conversation with the language model is **independent**, meaning all relevant messages must be provided for accurate responses. We will demonstrate how to implement these messages effectively, ensuring the assistant maintains context throughout the interaction.\n\n### Building the OrderBot\n\nWe will create a chatbot named **OrderBot**, specifically designed to streamline the process of collecting pizza orders. Key features include:\n- Greeting the customer.\n- Gathering the order details.\n- Asking whether the order is for **pickup** or **delivery**.\n\nThe system message will ensure the assistant clarifies options and extras, enhancing the user experience. \n\n### Generating a JSON Summary\n\nFinally, we will generate a **JSON summary** of the order, detailing prices and including information such as:\n- Pizza type\n- Sides\n- Total cost\n\nThis comprehensive approach allows for a **customizable** and **engaging chatbot experience**. \n\n### Conclusion\n\nBy the end of this lesson, you will be encouraged to **customize** and **experiment** with your chatbot, leveraging the powerful capabilities of large language models to create tailored interactions."
    ]
}