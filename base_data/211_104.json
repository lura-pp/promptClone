{
    "title": "Python Course Designer",
    "original_prompt": "Prompt: You are now a Python course designer with rich teaching experience and course development experience. Next, you will decompose the tasks given by the students and explain the decomposed tasks using suitable Python operations. The explanation process should be step by step, comprehensive, and concise. At the end, you should add a summary of this project, following the specific format shown in the example.\n\nExample:\n\u3010Input\u3011: Draw a French flag with three colors from left to right, with widths of 30:33:37 and a aspect ratio of 3:2\n\u3010Output\u3011:\nOverall Task: Draw a French flag\nSubtask 1: Implementation method: using the turtle library, script type required: xxx, implementation method: xxx\nSubtask 2: Implementation method: xxx\n\nTask Summary: This project achieved the production of the project by using the xx library in Python, applying the xxx knowledge during the production process, ...\n\nNext, I will provide the input. Are you ready?",
    "split_prompt": "This is a prompt description:```json\n{\n    \"spliting prompt\": {\n        \"role\": [\n            \"Python course designer\",\n            \"experienced teacher\",\n            \"course developer\"\n        ],\n        \"task_decomposition\": [\n            \"decompose the tasks given by the students\",\n            \"explain the decomposed tasks\",\n            \"use suitable Python operations\"\n        ],\n        \"explanation_style\": [\n            \"step by step\",\n            \"comprehensive\",\n            \"concise\"\n        ],\n        \"summary_format\": [\n            \"Overall Task\",\n            \"Subtask 1\",\n            \"Subtask 2\",\n            \"Task Summary\"\n        ],\n        \"example_input\": [\n            \"Draw a French flag with three colors from left to right, with widths of 30:33:37 and an aspect ratio of 3:2\"\n        ],\n        \"example_output\": [\n            \"Overall Task: Draw a French flag\",\n            \"Subtask 1: Implementation method: using the turtle library, script type required: xxx, implementation method: xxx\",\n            \"Subtask 2: Implementation method: xxx\",\n            \"Task Summary: This project achieved the production of the project by using the xx library in Python, applying the xxx knowledge during the production process, ...\"\n        ]\n    }\n}\n```",
    "input1": " Create a simple text-based adventure game where the player can explore a forest, encounter creatures, and collect items. The game should have at least three different paths, each leading to unique outcomes, and should allow the player to save their progress.\n\n",
    "input2": " Develop a Python program that simulates a basic banking system. The system should allow users to create accounts, deposit and withdraw money, check balances, and transfer funds between accounts. It should also include error handling for invalid transactions and a user-friendly interface.",
    "input1_ans": [
        "Overall Task: Create a simple text-based adventure game\n\nSubtask 1: Game Structure\n- Implementation method: Use a class-based structure to define the game, player, and environment.\n- Script type required: Python script (.py).\n- Implementation method: Create a `Game` class to manage the game flow, a `Player` class to handle player attributes and actions, and an `Environment` class to represent the forest and its paths.\n\nSubtask 2: Define Paths and Outcomes\n- Implementation method: Create a method within the `Environment` class to define at least three different paths.\n- Implementation method: Each path will lead to a unique outcome, which can be represented as functions or methods that describe the events that occur when a player chooses a path.\n\nSubtask 3: Encounter Creatures and Collect Items\n- Implementation method: Create a method to handle encounters with creatures and item collection.\n- Implementation method: Use lists or dictionaries to store creatures and items, and implement random encounters when the player explores the forest.\n\nSubtask 4: Save Progress\n- Implementation method: Use the `pickle` module or JSON to save the player's progress.\n- Implementation method: Create a method to serialize the player's state (attributes, inventory, current location) and save it to a file, and another method to load the saved state.\n\nSubtask 5: User Interface\n- Implementation method: Use simple text prompts and input functions to interact with the player.\n- Implementation method: Provide clear instructions and feedback based on player choices, ensuring a smooth user experience.\n\nTask Summary: This project achieved the creation of a text-based adventure game using Python, applying object-oriented programming principles to structure the game. The game allows players to explore a forest with multiple paths, encounter various creatures, and collect items, while also providing a feature to save and load progress using serialization techniques.",
        "### Overall Task: Create a Simple Text-Based Adventure Game\n\nThis task involves designing a text-based adventure game where players can explore a forest, encounter creatures, and collect items. The game will feature multiple paths leading to unique outcomes and will include a save feature for player progress.\n\n#### Subtask 1: Game Structure and Navigation\n- **Implementation Method**: Use a loop to allow continuous exploration until the player decides to quit.\n- **Details**:\n  - Create a main menu for starting the game, loading a saved game, and quitting.\n  - Define a function for exploring the forest that presents the player with three different paths.\n  - Each path will lead to a unique scenario or outcome.\n\n#### Subtask 2: Encounters and Items\n- **Implementation Method**: Use dictionaries or classes to represent creatures and items.\n- **Details**:\n  - Define a list of creatures that the player can encounter, each with unique attributes (e.g., friendly, hostile).\n  - Create items that can be collected, such as food, tools, or treasures.\n  - Implement functions to handle encounters, allowing players to choose actions (e.g., fight, flee, befriend).\n\n#### Subtask 3: Saving and Loading Progress\n- **Implementation Method**: Use file handling to save and load game state.\n- **Details**:\n  - Create a function to save the player's current state (location, inventory, health) to a file.\n  - Implement a function to load the game state from the file, allowing players to resume their adventure.\n\n### Task Summary\nThis project involves creating a text-based adventure game in Python where players can explore a forest, encounter various creatures, and collect items. The game will have three distinct paths leading to different outcomes, and it will include a save feature to allow players to save and load their progress. The implementation will utilize loops for navigation, dictionaries or classes for creatures and items, and file handling for saving/loading game state.\n\n### Example Code Snippet\nHere\u2019s a simple implementation outline to get you started:\n\n```python\nimport json\nimport random\n\nclass Game:\n    def __init__(self):\n        self.player = {\n            'location': 'forest entrance',\n            'inventory': [],\n            'health': 100\n        }\n        self.creatures = ['friendly deer', 'hostile wolf', 'mischievous sprite']\n        self.items = ['magic stone', 'healing herb', 'ancient coin']\n\n    def explore(self):\n        print(\"You are at the forest entrance. Choose a path to explore:\")\n        print(\"1. Path to the left\")\n        print(\"2. Path to the right\")\n        print(\"3. Path straight ahead\")\n        choice = input(\"Enter the number of your choice: \")\n        if choice == '1':\n            self.path_left()\n        elif choice == '2':\n            self.path_right()\n        elif choice == '3':\n            self.path_straight()\n        else:\n            print(\"Invalid choice. Try again.\")\n            self.explore()\n\n    def path_left(self):\n        encounter = random.choice(self.creatures)\n        print(f\"You encounter a {encounter}.\")\n        # Handle encounter logic here...\n\n    def path_right(self):\n        item_found = random.choice(self.items)\n        print(f\"You found a {item_found}.\")\n        self.player['inventory'].append(item_found)\n\n    def path_straight(self):\n        print(\"You find a peaceful clearing. You can rest here.\")\n        # Additional logic for resting...\n\n    def save_game(self):\n        with open('save_game.json', 'w') as f:\n            json.dump(self.player, f)\n        print(\"Game saved!\")\n\n    def load_game(self):\n        with open('save_game.json', 'r') as f:\n            self.player = json.load(f)\n        print(\"Game loaded!\")\n\n# Main game loop\ngame = Game()\nwhile True:\n    action = input(\"Type 'explore' to explore the forest, 'save' to save, 'load' to load, or 'quit' to exit: \")\n    if action == 'explore':\n        game.explore()\n    elif action == 'save':\n        game.save_game()\n    elif action == 'load':\n        game.load_game()\n    elif action == 'quit':\n        print(\"Thanks for playing!\")\n        break\n    else:\n        print(\"Invalid action. Try again.\")\n```\n\nThis code provides a basic structure for the game, allowing for exploration, encounters, item collection, and saving/loading progress. You can expand upon this by adding more detailed encounters, items, and paths."
    ],
    "input2_ans": [
        "\u3010Input\u3011: Develop a Python program that simulates a basic banking system. The system should allow users to create accounts, deposit and withdraw money, check balances, and transfer funds between accounts. It should also include error handling for invalid transactions and a user-friendly interface.\n\n\u3010Output\u3011:\nOverall Task: Develop a basic banking system in Python\n\nSubtask 1: Account Creation\n- Implementation method: Create a class `BankAccount` to represent a bank account.\n- Script type required: Class definition.\n- Implementation method: Define methods for initializing an account with attributes like account number, account holder's name, and balance.\n\nSubtask 2: Deposit Money\n- Implementation method: Add a method `deposit(amount)` in the `BankAccount` class.\n- Script type required: Method definition.\n- Implementation method: This method should increase the account balance by the specified amount and include error handling for negative deposits.\n\nSubtask 3: Withdraw Money\n- Implementation method: Add a method `withdraw(amount)` in the `BankAccount` class.\n- Script type required: Method definition.\n- Implementation method: This method should decrease the account balance by the specified amount, ensuring that the balance does not go negative, and include error handling for insufficient funds.\n\nSubtask 4: Check Balance\n- Implementation method: Add a method `check_balance()` in the `BankAccount` class.\n- Script type required: Method definition.\n- Implementation method: This method should return the current balance of the account.\n\nSubtask 5: Transfer Funds\n- Implementation method: Add a method `transfer(amount, target_account)` in the `BankAccount` class.\n- Script type required: Method definition.\n- Implementation method: This method should withdraw the specified amount from the current account and deposit it into the target account, including error handling for invalid transfers.\n\nSubtask 6: User Interface\n- Implementation method: Create a simple command-line interface (CLI) using a loop to interact with the user.\n- Script type required: Input/output handling.\n- Implementation method: Use `input()` to get user commands and display options for creating accounts, depositing, withdrawing, checking balance, and transferring funds.\n\nSubtask 7: Error Handling\n- Implementation method: Implement try-except blocks in methods to handle exceptions for invalid transactions.\n- Script type required: Exception handling.\n- Implementation method: Ensure that the program gracefully handles errors such as invalid input, insufficient funds, and non-existent accounts.\n\nTask Summary: This project achieved the development of a basic banking system using Python by implementing a class-based structure for bank accounts, allowing for operations such as account creation, deposits, withdrawals, balance checks, and fund transfers. Error handling was incorporated to manage invalid transactions, and a user-friendly command-line interface was created to enhance user interaction. This project utilized object-oriented programming principles and exception handling techniques to ensure robustness and usability.",
        "### Overall Task: Develop a Basic Banking System in Python\n\nThis task involves creating a Python program that simulates a basic banking system with functionalities such as account creation, deposits, withdrawals, balance checks, and fund transfers. The program should also handle errors gracefully and provide a user-friendly interface.\n\n### Subtask 1: Account Creation\n- **Implementation Method**: Create a class `BankAccount` to represent a bank account. This class should have attributes for account holder's name, account number, and balance.\n- **Script Type Required**: Class-based implementation.\n- **Implementation Steps**:\n  1. Define the `BankAccount` class with an `__init__` method to initialize account details.\n  2. Create a method `create_account` that prompts the user for their name and initializes a new account with a unique account number.\n\n### Subtask 2: Deposit and Withdraw Money\n- **Implementation Method**: Add methods to the `BankAccount` class for depositing and withdrawing money.\n- **Implementation Steps**:\n  1. Define a method `deposit` that takes an amount as input and adds it to the account balance.\n  2. Define a method `withdraw` that checks if the withdrawal amount is less than or equal to the balance before deducting it. If not, raise an error.\n\n### Subtask 3: Check Balance\n- **Implementation Method**: Add a method to check the current balance of the account.\n- **Implementation Steps**:\n  1. Define a method `check_balance` that returns the current balance of the account.\n\n### Subtask 4: Transfer Funds Between Accounts\n- **Implementation Method**: Implement a method to transfer funds from one account to another.\n- **Implementation Steps**:\n  1. Define a method `transfer` that takes another `BankAccount` object and an amount as input.\n  2. Ensure that the transfer amount is valid and deduct it from the sender's account while adding it to the receiver's account.\n\n### Subtask 5: User-Friendly Interface and Error Handling\n- **Implementation Method**: Create a simple command-line interface for user interaction.\n- **Implementation Steps**:\n  1. Use a loop to present a menu of options to the user (create account, deposit, withdraw, check balance, transfer funds, exit).\n  2. Implement error handling using try-except blocks to manage invalid inputs and transactions.\n\n### Task Summary\nThis project achieves the simulation of a basic banking system using Python by implementing a `BankAccount` class that encapsulates the functionalities of account management. The program allows users to create accounts, deposit and withdraw money, check balances, and transfer funds between accounts. Error handling is incorporated to manage invalid transactions, and a user-friendly command-line interface is provided for ease of use. \n\n### Example Code Implementation\nHere is a basic implementation of the described banking system:\n\n```python\nclass BankAccount:\n    account_counter = 0\n\n    def __init__(self, account_holder):\n        self.account_holder = account_holder\n        self.account_number = BankAccount.account_counter + 1\n        self.balance = 0\n        BankAccount.account_counter += 1\n\n    def deposit(self, amount):\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive.\")\n        self.balance += amount\n        print(f\"Deposited: ${amount}. New balance: ${self.balance}.\")\n\n    def withdraw(self, amount):\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive.\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient funds.\")\n        self.balance -= amount\n        print(f\"Withdrew: ${amount}. New balance: ${self.balance}.\")\n\n    def check_balance(self):\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        if amount <= 0:\n            raise ValueError(\"Transfer amount must be positive.\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient funds for transfer.\")\n        self.withdraw(amount)\n        other_account.deposit(amount)\n        print(f\"Transferred: ${amount} to account {other_account.account_number}.\")\n\ndef main():\n    accounts = {}\n    while True:\n        print(\"\\n1. Create Account\\n2. Deposit\\n3. Withdraw\\n4. Check Balance\\n5. Transfer Funds\\n6. Exit\")\n        choice = input(\"Choose an option: \")\n\n        if choice == '1':\n            name = input(\"Enter account holder's name: \")\n            account = BankAccount(name)\n            accounts[account.account_number] = account\n            print(f\"Account created. Account Number: {account.account_number}\")\n\n        elif choice == '2':\n            acc_num = int(input(\"Enter account number: \"))\n            amount = float(input(\"Enter amount to deposit: \"))\n            if acc_num in accounts:\n                accounts[acc_num].deposit(amount)\n            else:\n                print(\"Account not found.\")\n\n        elif choice == '3':\n            acc_num = int(input(\"Enter account number: \"))\n            amount = float(input(\"Enter amount to withdraw: \"))\n            if acc_num in accounts:\n                try:\n                    accounts[acc_num].withdraw(amount)\n                except ValueError as e:\n                    print(e)\n            else:\n                print(\"Account not found.\")\n\n        elif choice == '4':\n            acc_num = int(input(\"Enter account number: \"))\n            if acc_num in accounts:\n                balance = accounts[acc_num].check_balance()\n                print(f\"Current balance: ${balance}.\")\n            else:\n                print(\"Account not found.\")\n\n        elif choice == '5':\n            from_acc = int(input(\"Enter your account number: \"))\n            to_acc = int(input(\"Enter recipient account number: \"))\n            amount = float(input(\"Enter amount to transfer: \"))\n            if from_acc in accounts and to_acc in accounts:\n                try:\n                    accounts[from_acc].transfer(accounts[to_acc], amount)\n                except ValueError as e:\n                    print(e)\n            else:\n                print(\"One or both accounts not found.\")\n\n        elif choice == '6':\n            print(\"Exiting the banking system.\")\n            break\n\n        else:\n            print(\"Invalid option. Please try again.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code provides a simple banking system with the required functionalities and error handling. Users can create accounts, deposit and withdraw money, check their balance, and transfer funds between accounts through a command-line interface."
    ]
}